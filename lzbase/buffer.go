package lzbase

import "io"

// buffer implements a ring buffer with features to support an LZMA reader and
// writer dictionary.
//
// The ring buffer supports writing at the end offset and writing at the cursor
// offset. The field start stores the start offset of the buffer, but could be
// computed by b.end - b.Cap().
//
// The reader dictionary will have the head at the end offset the writer
// dictionary will have the head at the cursor offset.
type buffer struct {
	// plain constant length field to store the data
	data []byte
	// start offset of the buffer; b.end - len(b.data)
	start int64
	// offset for reading
	cursor int64
	// end offset of the current buffer window; use setEnd method for
	// updates
	end int64
	// writeLimit gives the maximum distance between end and cursor
	writeLimit int64
	// marks the buffer as closed for writing
	closed bool
}

// errors generated by the ring buffer functions
var (
	errOffset       = newError("offset outside buffer range")
	errAgain        = newError("buffer exceeded; repeat")
	errNegLen       = newError("length is negative")
	errNrOverflow   = newError("number overflow")
	errCapacity     = newError("capacity out of range")
	errClosedBuffer = newError("buffer is closed for writing")
)

// capacity returns the size of the ring buffer in bytes
func (b *buffer) capacity() int64 {
	return int64(len(b.data))
}

// length returns the number of bytes already stored in the buffer. It will
// increase from zero to the buffer capacity.
func (b *buffer) length() int {
	return int(b.end - b.start)
}

// readable returns the number of bytes that are currently available for
// reading.
func (b *buffer) readable() int {
	return int(b.end - b.cursor)
}

// writable returns the number of byte that are currently available for writing.
func (b *buffer) writable() int {
	return int(b.cursor + int64(b.writeLimit) - b.end)
}

// setEnd updates the start and end fields. Use it always to update the end
// field.
func (b *buffer) setEnd(x int64) {
	if x < 0 {
		panic("b.end overflow?")
	}
	b.end = x
	b.start = x - int64(len(b.data))
	if b.start < 0 {
		b.start = 0
	}
}

// index computes the index into the data slice for a particular offset.
func (b *buffer) index(off int64) int {
	if off < 0 {
		panic("negative offsets are not supported")
	}
	return int(off % int64(len(b.data)))
}

// initBuffer initializes an already allocated buffer.
func initBuffer(b *buffer, capacity int64) error {
	c := int(capacity)
	if c <= 0 {
		return errCapacity
	}
	*b = buffer{data: make([]byte, c), writeLimit: capacity}
	return nil
}

// newBuffer creates a new buffer instance.
func newBuffer(capacity int64) (b *buffer, err error) {
	b = new(buffer)
	err = initBuffer(b, capacity)
	return
}

// readOff is a helper method for the ReadAt and Read methods.
func (b *buffer) readOff(p []byte, off int64) {
	for len(p) > 0 {
		s := b.index(off)
		m := copy(p, b.data[s:])
		off += int64(m)
		p = p[m:]
	}
}

// readAt reads data into p at the specified offset. The offset must be inside
// the buffer. It the slice cannot be completely filled errAgain is reported
// unless the buffer is not closed. In that case the function returns io.EOF.
func (b *buffer) readAt(p []byte, off int64) (n int, err error) {
	if off < b.start {
		return 0, errOffset
	}
	k := b.end - off
	n = len(p)
	if k < int64(n) {
		if k < 0 {
			return 0, errOffset
		}
		if b.closed {
			err = io.EOF
		} else {
			err = errAgain
		}
		n = int(k)
	}
	b.readOff(p[:n], off)
	return
}

// read tries to read data into the buffer. No error is returned if n < len(p).
func (b *buffer) read(p []byte) (n int, err error) {
	k := b.end - b.cursor
	n = len(p)
	if k < int64(n) {
		if k < 0 {
			panic("wrong b.cursor")
		}
		if k == 0 && b.closed {
			return 0, io.EOF
		}
		n = int(k)
	}
	b.readOff(p[:n], b.cursor)
	b.cursor += int64(n)
	return
}

// discard skips n bytes of reading bytes. If less than n bytes are skipped
// errAgain or io.EOF if closed is returned.
func (b *buffer) discard(n int) (discarded int, err error) {
	if n < 0 {
		return 0, errNegLen
	}
	k := b.end - b.cursor
	if k < int64(n) {
		if k < 0 {
			panic("wrong b.cursor")
		}
		if b.closed {
			err = io.EOF
		} else {
			err = errAgain
		}
		n = int(k)
	}
	discarded = n
	b.cursor += int64(n)
	return
}

// copyAt is a helper for copyTo.
func (b *buffer) copyAt(w io.Writer, n int, off int64) (copied int, err error) {
	start, end := off, off+int64(n)
	e := b.index(end)
	for off < end {
		s := b.index(off)
		var q []byte
		if s < e {
			q = b.data[s:e]
		} else {
			q = b.data[s:]
		}
		var m int
		m, err = w.Write(q)
		off += int64(m)
		if err != nil {
			break
		}
	}
	return int(off - start), err
}

// copyTo behaves like read but the data is written into the writer.
func (b *buffer) copyTo(w io.Writer, n int) (copied int, err error) {
	if n < 0 {
		return 0, errNegLen
	}
	k := b.end - b.cursor
	if k < int64(n) {
		if k < 0 {
			panic("wrong b.cursor")
		}
		if k == 0 && b.closed {
			return 0, io.EOF
		}
		n = int(k)
	}
	copied, err = b.copyAt(w, n, b.cursor)
	b.cursor += int64(copied)
	return
}

// readByteAt reads a single byte at the given offset.
func (b *buffer) readByteAt(off int64) (c byte, err error) {
	if !(b.start <= off && off <= b.end) {
		return 0, errOffset
	}
	if off == b.end {
		if b.closed {
			return 0, io.EOF
		}
		return 0, errAgain
	}
	i := b.index(off)
	return b.data[i], nil
}

// readByte reads a single byte.
func (b *buffer) readByte() (c byte, err error) {
	if b.cursor == b.end {
		if b.closed {
			return 0, io.EOF
		}
		return 0, errAgain
	}
	i := b.index(b.cursor)
	b.cursor++
	return b.data[i], nil
}

// writeSlice writes the slice p unconditionally into the buffer.
func (b *buffer) writeSlice(p []byte) {
	off := b.end
	for len(p) > 0 {
		i := b.index(off)
		m := copy(b.data[i:], p)
		off += int64(m)
		if off < 0 {
			panic("overflow b.end")
		}
		p = p[m:]
	}
	b.setEnd(off)
}

// Write puts data into the buffer. If n < len(p) errAgain is returned. If the
// buffer is closed errClosedBuffer is returned.
func (b *buffer) Write(p []byte) (n int, err error) {
	if b.closed {
		return 0, errClosedBuffer
	}
	n = b.writable()
	if n < len(p) {
		err = errAgain
		p = p[:n]
	}
	n = len(p)
	b.writeSlice(p)
	return
}

// writes a single byte into the buffer.
func (b *buffer) writeByte(c byte) error {
	if b.closed {
		return errClosedBuffer
	}
	if b.writable() < 1 {
		return errAgain
	}
	i := b.index(b.end)
	b.data[i] = c
	b.setEnd(b.end + 1)
	return nil
}

// writeRepOff writes a match at the given offset into the buffer.
func (b *buffer) writeRepOff(n int, off int64) (written int, err error) {
	if n < 0 {
		return 0, errNegLen
	}
	if b.closed {
		return 0, errClosedBuffer
	}
	if !(b.start <= off && off < b.end) {
		return 0, errOffset
	}
	if b.writable() < n {
		return 0, errAgain
	}
	end := off + int64(n)
	e := b.index(end)
	for off < end {
		s := b.index(off)
		var t int
		if end > b.end {
			t = b.index(b.end)
		} else {
			t = e
		}
		var q []byte
		if s < t {
			q = b.data[s:t]
		} else {
			q = b.data[s:]
		}
		b.writeSlice(q)
		off += int64(len(q))
	}
	return n, nil
}

// close closes the buffer.
func (b *buffer) closeBuffer() error {
	b.closed = true
	return nil
}

// equalBytes count the equal bytes at off1 and off2 until max is reached.
func (b *buffer) equalBytes(off1, off2 int64, max int) int {
	if off1 < b.start || off2 < b.start {
		return 0
	}
	if max < 0 {
		return 0
	}
	n := b.end - off1
	if n < int64(max) {
		if n < 1 {
			return 0
		}
		max = int(n)
	}
	n = b.end - off2
	if n < int64(max) {
		if n < 1 {
			return 0
		}
		max = int(n)
	}
	for k := 0; k < max; k++ {
		i, j := b.index(off1+int64(k)), b.index(off2+int64(k))
		if b.data[i] != b.data[j] {
			return k
		}
	}
	return max
}
