// Package buz provides functions to compute hashes for a byte slice.
package buz

import "fmt"

// The table with the random hash values is generated by buzgen. Usually
// that is not necessary.
//go:generate buzgen table.go

// SingleHash computes a single hash value for the given byte slice.
func SingleHash(data []byte) uint32 {
	if len(data) == 0 {
		return 0
	}
	h := table[data[0]]
	for _, b := range data[1:] {
		h = (h<<1 | h>>31) ^ table[b]
	}
	return h
}

// Hash is slice storing the has value for lengths 2, 3, ..., len(data)
// in a slice.
type Hash []uint32

// SetDataLen sets the data length supported by hash.
func (h *Hash) SetDataLen(n int) {
	if n < 0 {
		panic(fmt.Errorf("data length n must not be negative"))
	}
	if n < 2 {
		*h = nil
	}
	*h = make(Hash, 0, n-1)
}

// MakeHash creates a new hash with the data length n.
func MakeHash(n int) Hash {
	var h Hash
	h.SetDataLen(n)
	return h
}

// DataLen returns the data length for the slice.
func (h Hash) DataLen() int {
	if h == nil {
		return 0
	}
	return cap(h) + 1
}

// Compute calculates the hash values for the data slice. The hash
// slice is adapted to contain only the valid hashes.
func (h *Hash) Compute(data []byte) {
	if cap(*h) == 0 || len(data) < 2 {
		return
	}
	n := cap(*h) + 1
	switch {
	case n < len(data):
		data = data[:n]
	case n > len(data):
		n = len(data)
	}
	*h = (*h)[:n-1]
	g := table[data[0]]
	for i, b := range data[1:] {
		g = (g<<1 | g>>31) ^ table[b]
		(*h)[i] = g
	}
}
