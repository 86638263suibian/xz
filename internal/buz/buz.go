// Package buz provides functions to compute hashes for a byte slice.
package buz

import "fmt"

// The table with the random hash values is generated by buzgen. Usually
// that is not necessary.
//go:generate buzgen table.go

// Hash is slice storing the has value for lengths 2, 3, ..., len(data)
// in a slice.
type Hash []uint32

// SetDataLen sets the data length supported by hash.
func (h *Hash) SetDataLen(n int) {
	if n < 0 {
		panic(fmt.Errorf("data length n must not be negative"))
	}
	if n < 2 {
		*h = nil
	}
	*h = make(Hash, n-1)
}

// MakeHash creates a new hash with the data length n.
func MakeHash(n int) Hash {
	var h Hash
	h.SetDataLen(n)
	return h
}

// DataLen returns the data length for the slice.
func (h Hash) DataLen() int {
	if h == nil {
		return 0
	}
	return len(h) + 1
}

// Compute calculates the hash values for the data slice. It returns the
// number of entries valid after the update. The argument p might be
// shorter than the hash value.
func (h Hash) Compute(data []byte) int {
	if len(h) == 0 || len(data) < 2 {
		return 0
	}
	n := len(h) + 1
	if n < len(data) {
		data = data[:n]
	}
	g := table[data[0]]
	for i, b := range data[1:] {
		g = (g<<1 | g>>31) ^ table[b]
		h[i] = g
	}
	return len(data) - 1
}
